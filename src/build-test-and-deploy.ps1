<#
Orchestration script to build solution, docker image and run integration tests.
This script is intended to live in the `src/` folder next to `Asionyx.sln`.
Usage: pwsh ./build-test-and-deploy.ps1
#>
param()


# Note: static appsettings.json files are checked into each project folder so the
# runtime does not require appsettings to be generated by this script.

function New-Directory {
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string] $Path
    )
    if (-not (Test-Path $Path)) { New-Item -ItemType Directory -Path $Path | Out-Null }
}

function Restore-Solution {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # local variables used in this function
    $solutionFileName = $buildContext.solutionFileName

    Write-Host "Restoring solution: $solutionFileName" -ForegroundColor Green
    dotnet restore $solutionFileName
    if ($LASTEXITCODE -ne 0) { Write-Host "dotnet restore failed" -ForegroundColor Red; exit $LASTEXITCODE }

    Write-Host "Building solution: $solutionFileName" -ForegroundColor Green
    dotnet build $solutionFileName -c Release
    if ($LASTEXITCODE -ne 0) { Write-Host "dotnet build failed" -ForegroundColor Red; exit $LASTEXITCODE }
}

function Publish-Projects {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # locals
    $publishRoot = $buildContext.PublishRoot
    Write-Host "Publishing projects to $publishRoot..." -ForegroundColor Green
    if (Test-Path $publishRoot) { Remove-Item $publishRoot -Recurse -Force }

    $projects = @(
        @{ Name = "$($buildContext.ProjectName).Services.Deployment"; Out = 'deployment'; Args = '' },
        @{ Name = "$($buildContext.ProjectName).Services.Deployment.SystemD"; Out = 'systemd'; Args = '-r linux-x64 -p:PublishSingleFile=true -p:PublishTrimmed=false -p:SelfContained=true' },
        @{ Name = "$($buildContext.ProjectName).Services.HelloWorld"; Out = 'helloworld'; Args = '' }
    )

    $projects | % {
        $outDir = Join-Path $publishRoot $_.Out
        New-Directory -Path $outDir
        Write-Host "Publishing $($_.Name) -> $outDir" -ForegroundColor Green
        if ([string]::IsNullOrWhiteSpace($_.Args)) {
            dotnet publish $_.Name -c Release -o $outDir
        } else {
            $extraArgs = $_.Args -split ' '
            $argList = @('publish', $_.Name, '-c', 'Release') + $extraArgs + @('-o', $outDir)
            & dotnet @argList
        }
        if ($LASTEXITCODE -ne 0) { Write-Host "dotnet publish $($_.Name) failed" -ForegroundColor Red; exit $LASTEXITCODE }
    }
}

function Invoke-DockerBuild {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # locals
    $dockerfile = $buildContext.Dockerfile
    $dockerImage = $buildContext.DockerImage

    Write-Host "Building docker image $dockerImage (linux)" -ForegroundColor Green
    docker build -f $dockerfile -t $dockerImage .
}

function Remove-DockerImage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    $dockerImage = $buildContext.DockerImage
    Write-Host "Removing docker image $dockerImage (if present)" -ForegroundColor Green
    try {
        docker rmi -f $dockerImage | Out-Null
    } catch {
        Write-Host "docker image removal failed or image not present: $_" -ForegroundColor Yellow
    }
}

# Container lifecycle is managed by integration tests (Testcontainers). The orchestrator
# should only build/publish and build the Docker image; it must NOT start or remove containers.

function Test-Integration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )
        $resultsDir = Join-Path $PSScriptRoot "TestResults"
        if (-not (Test-Path $resultsDir)) { New-Item -ItemType Directory -Path $resultsDir | Out-Null }
        Write-Host "\n==== Running: dotnet test $solutionFileName -c Debug --collect=`"XPlat Code Coverage`" --logger trx --results-directory $resultsDir ====" -ForegroundColor Yellow
        $testOutput = dotnet test $solutionFileName -c Debug --collect:"XPlat Code Coverage" --logger trx --results-directory $resultsDir
        Write-Host $testOutput
        $covFiles = Get-ChildItem -Path $resultsDir -Recurse -Filter 'coverage.cobertura.xml' | Sort-Object LastWriteTime -Descending
        if ($covFiles.Count -eq 0) {
            Write-Host "No code coverage data found for any test project." -ForegroundColor Red
            return
        }
        Write-Host "\n==== CODE COVERAGE SUMMARY ====" -ForegroundColor Cyan
        foreach ($file in $covFiles) {
            Write-Host ("Coverage file: $file") -ForegroundColor Green
            $lines = Get-Content $file | Select-String -Pattern '<coverage ' -Context 0,10
            if ($lines) {
                $lines | ForEach-Object { Write-Host $_.Line }
            } else {
                Write-Host "(Coverage XML generated, but no summary line found)" -ForegroundColor Yellow
            }
        }
        Write-Host "==== END COVERAGE SUMMARY ====" -ForegroundColor Cyan
}

function Save-LogsAndCleanup {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    $scriptDir = $buildContext.ScriptDir
    $diagBase = Join-Path $scriptDir 'artifacts'
    if (-not (Test-Path $diagBase)) { New-Item -ItemType Directory -Path $diagBase | Out-Null }
    $diagHost = Join-Path $diagBase ("diagnostics_{0}" -f (Get-Date -Format 'yyyyMMddHHmmss'))
    if (-not (Test-Path $diagHost)) { New-Item -ItemType Directory -Path $diagHost | Out-Null }

    # We do not start containers here; integration tests start/stop containers themselves.
    # Only perform local cleanup of publish artifacts and leave docker images/containers alone.
    try {
        if (Test-Path $buildContext.PublishRoot) {
            Write-Host "Cleaning up publish folder $($buildContext.PublishRoot)" -ForegroundColor Green
            Remove-Item $buildContext.PublishRoot -Recurse -Force
        }
        Write-Host "Orchestration complete (image built; container lifecycle is test-managed)." -ForegroundColor Green
    } catch {
        Write-Host "Cleanup failed: $_" -ForegroundColor Yellow
        exit 0
    }
}

$ErrorActionPreference = 'Stop'
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $scriptDir

# Centralized configuration (edit here)
$PublishRoot = Join-Path $scriptDir 'publish'
$projectName = "Asionyx"
$solutionFileName = "$($projectName).sln"
$DeploymentProjectPath = Join-Path $scriptDir "$($projectName).Services.Deployment"
$SystemdProjectPath = Join-Path $scriptDir "$($projectName).Services.Deployment.SystemD"
$HelloWorldProjectPath = Join-Path $scriptDir "$($projectName).Services.HelloWorld"
$Dockerfile = "$($projectName).Services.Deployment.Docker/Dockerfile"
$DockerImage = 'asionyx/deployment:local'
$ContainerName = 'asionyx_local'
$HostPort = 5000
$MaxWaitSeconds = 60
$DiagnosticsToStdout = $true
$DiagnosticsDir = '/var/asionyx/diagnostics'
$InsecureTesting = $true


# Build context object passed to every function
$buildContext = [PSCustomObject]@{
    ScriptDir = $scriptDir
    PublishRoot = $PublishRoot
    ProjectName = $projectName
    DeploymentProjectPath = $DeploymentProjectPath
    SystemdProjectPath = $SystemdProjectPath
    HelloWorldProjectPath = $HelloWorldProjectPath
    Dockerfile = $Dockerfile
    DockerImage = $DockerImage
    ContainerName = $ContainerName
    HostPort = $HostPort
    MaxWaitSeconds = $MaxWaitSeconds
    DiagnosticsToStdout = $DiagnosticsToStdout
    DiagnosticsDir = $DiagnosticsDir
    InsecureTesting = $InsecureTesting
    solutionFileName = $solutionFileName
}

Restore-Solution -buildContext $buildContext
Publish-Projects -buildContext $buildContext
Invoke-DockerBuild -buildContext $buildContext

# Run integration tests but always remove the built image afterwards. Container
# lifecycle remains managed by the tests themselves.
try {
    Test-Integration -buildContext $buildContext
} finally {
    Remove-DockerImage -buildContext $buildContext
    Save-LogsAndCleanup -buildContext $buildContext
}