<#
Orchestration script to build solution, docker image and run integration tests.
This script is intended to live in the `src/` folder next to `Asionyx.sln`.
Usage: pwsh ./build-test-and-deploy.ps1
#>
param()


# Installs or updates the reportgenerator tool as a local tool in .config
function Install-ReportGeneratorTool {
    [CmdletBinding()]
    param()

    $localToolManifest = Join-Path $PSScriptRoot ".config/dotnet-tools.json"
    if (-not (Test-Path (Split-Path $localToolManifest))) {
        New-Item -ItemType Directory -Path (Split-Path $localToolManifest) | Out-Null
    }
    if (-not (Test-Path "$PSScriptRoot/.config")) {
        New-Item -ItemType Directory -Path "$PSScriptRoot/.config" | Out-Null
    }
    if (-not (Test-Path "$PSScriptRoot/.config/dotnet-tools.json")) {
        dotnet new tool-manifest --output $PSScriptRoot/.config | Out-Null
    }
    Push-Location "$PSScriptRoot/.config"
    dotnet tool install dotnet-reportgenerator-globaltool --local --ignore-failed-sources | Out-Null
    Pop-Location
}

# Note: static appsettings.json files are checked into each project folder so the
# runtime does not require appsettings to be generated by this script.

function New-Directory {
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string] $Path
    )
    if (-not (Test-Path $Path)) { New-Item -ItemType Directory -Path $Path | Out-Null }
}

function Restore-Solution {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # local variables used in this function
    $solutionFileName = $buildContext.solutionFileName

    Write-Host "Restoring solution: $solutionFileName" -ForegroundColor Green
    dotnet restore $solutionFileName
    if ($LASTEXITCODE -ne 0) { Write-Host "dotnet restore failed" -ForegroundColor Red; exit $LASTEXITCODE }

    Write-Host "Building solution: $solutionFileName" -ForegroundColor Green
    dotnet build $solutionFileName -c Release
    if ($LASTEXITCODE -ne 0) { Write-Host "dotnet build failed" -ForegroundColor Red; exit $LASTEXITCODE }
}

function Publish-Projects {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # locals
    $publishRoot = $buildContext.PublishRoot
    Write-Host "Publishing projects to $publishRoot..." -ForegroundColor Green
    if (Test-Path $publishRoot) { Remove-Item $publishRoot -Recurse -Force }

    $projects = @(
        @{ Name = "$($buildContext.ProjectName).Services.Deployment"; Out = 'deployment'; Args = '' },
        @{ Name = "$($buildContext.ProjectName).Services.Deployment.SystemD"; Out = 'systemd'; Args = '-r linux-x64 -p:PublishSingleFile=true -p:PublishTrimmed=false -p:SelfContained=true' },
        @{ Name = "$($buildContext.ProjectName).Services.HelloWorld"; Out = 'helloworld'; Args = '' }
    )

    $projects | % {
        $outDir = Join-Path $publishRoot $_.Out
        New-Directory -Path $outDir
        Write-Host "Publishing $($_.Name) -> $outDir" -ForegroundColor Green
        if ([string]::IsNullOrWhiteSpace($_.Args)) {
            dotnet publish $_.Name -c Release -o $outDir
        } else {
            $extraArgs = $_.Args -split ' '
            $argList = @('publish', $_.Name, '-c', 'Release') + $extraArgs + @('-o', $outDir)
            & dotnet @argList
        }
        if ($LASTEXITCODE -ne 0) { Write-Host "dotnet publish $($_.Name) failed" -ForegroundColor Red; exit $LASTEXITCODE }
    }
}

function Invoke-DockerBuild {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    # locals
    $dockerfile = $buildContext.Dockerfile
    $dockerImage = $buildContext.DockerImage

    Write-Host "Building docker image $dockerImage (linux)" -ForegroundColor Green
    docker build -f $dockerfile -t $dockerImage .
}

function Remove-DockerImage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )
    if ($buildContext.ShouldCleanupDockerImage -ne $true) 
    {
        Write-Host "Skipping docker image removal as per configuration." -ForegroundColor Yellow
        return
    }
    $dockerImage = $buildContext.DockerImage
    Write-Host "Removing docker image $dockerImage (if present)" -ForegroundColor Green
    try 
    {
        docker rmi -f $dockerImage | Out-Null
    } 
    catch 
    {
        Write-Host "docker image removal failed or image not present: $_" -ForegroundColor Yellow
    }
}

# Container lifecycle is managed by integration tests (Testcontainers). The orchestrator
# should only build/publish and build the Docker image; it must NOT start or remove containers.

function Test-Integration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )
    $resultsDir = Join-Path $PSScriptRoot "TestResults"
    if (-not (Test-Path $resultsDir)) { New-Item -ItemType Directory -Path $resultsDir | Out-Null }
    Write-Host "==== Running: dotnet test  ====" -ForegroundColor Yellow
    dotnet test $solutionFileName -c Debug --collect:"XPlat Code Coverage" --logger trx --results-directory $resultsDir
    if ($LASTEXITCODE -ne 0) { Write-Host "dotnet test failed" -ForegroundColor Red; exit $LASTEXITCODE }
    $script:covFiles = Get-ChildItem -Path $resultsDir -Recurse -Filter 'coverage.cobertura.xml' | Sort-Object LastWriteTime -Descending
    if ($script:covFiles.Count -eq 0) {
        Write-Host "No code coverage data found for any test project." -ForegroundColor Red
        return
    }
    Write-Host "==== CODE COVERAGE SUMMARY ====" -ForegroundColor Cyan
    foreach ($file in $script:covFiles) {
        $lines = Get-Content $file | Select-String -Pattern '<coverage ' -Context 0,10
        if ($lines) {
            $lines | ForEach-Object { Write-Verbose $_.Line }
        } else {
            Write-Host "(Coverage XML generated, but no summary line found)" -ForegroundColor Yellow
        }
    }
    Write-Host "==== END COVERAGE SUMMARY ====" -ForegroundColor Cyan
}
function New-CoverageReport {
    param(
        [Parameter(Mandatory = $true)]
        $buildContext,
        [Parameter(Mandatory = $true)]
        $covFiles
    )
    # After collecting coverage, generate a human-readable report using ReportGenerator
    $reportDir = Join-Path $PSScriptRoot "TestResults/CoverageReport"
    if (-not (Test-Path $reportDir)) { New-Item -ItemType Directory -Path $reportDir | Out-Null }
    if ($covFiles.Count -gt 0) {
        Write-Host "==== Generating HTML coverage report with ReportGenerator ====" -ForegroundColor Yellow
        # Change to .config directory to run the local tool
        Push-Location "$PSScriptRoot/.config"
        # Use absolute paths for reportgenerator arguments
        $absCovFiles = $covFiles | ForEach-Object { (Resolve-Path $_.FullName).Path }
        $absReportDir = (Resolve-Path $reportDir).Path
        $reportArgs = @(
            "--"
            ("-reports:" + ($absCovFiles -join ';'))
            ("-targetdir:" + $absReportDir)
            "-reporttypes:HtmlInline_AzurePipelines;TextSummary"
        )
        dotnet tool run reportgenerator @reportArgs
        Pop-Location
        if (Test-Path (Join-Path $reportDir 'index.html')) {
            Write-Host "HTML coverage report generated at: $reportDir\index.html" -ForegroundColor Green
            $summaryFile = Join-Path $reportDir 'Summary.txt'
            if (Test-Path $summaryFile) {
                Write-Host "==== COVERAGE SUMMARY ====" -ForegroundColor Cyan
                Get-Content $summaryFile | Write-Host
                Write-Host "==== END COVERAGE SUMMARY ====" -ForegroundColor Cyan
            }
        } else {
            Write-Host "ReportGenerator did not produce an index.html file." -ForegroundColor Red
        }
    }
}
function Save-LogsAndCleanup {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $buildContext
    )

    $scriptDir = $buildContext.ScriptDir
    $diagBase = Join-Path $scriptDir 'artifacts'
    if (-not (Test-Path $diagBase)) { New-Item -ItemType Directory -Path $diagBase | Out-Null }
    $diagHost = Join-Path $diagBase ("diagnostics_{0}" -f (Get-Date -Format 'yyyyMMddHHmmss'))
    if (-not (Test-Path $diagHost)) { New-Item -ItemType Directory -Path $diagHost | Out-Null }

    # We do not start containers here; integration tests start/stop containers themselves.
    # Only perform local cleanup of publish artifacts and leave docker images/containers alone.
    try {
        if (Test-Path $buildContext.PublishRoot) {
            Write-Host "Cleaning up publish folder $($buildContext.PublishRoot)" -ForegroundColor Green
            Remove-Item $buildContext.PublishRoot -Recurse -Force
        }
        Write-Host "Orchestration complete (image built; container lifecycle is test-managed)." -ForegroundColor Green
    } catch {
        Write-Host "Cleanup failed: $_" -ForegroundColor Yellow
        exit 0
    }
}

$ErrorActionPreference = 'Stop'
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $scriptDir

function Remove-Directories
 {
    param (
        $directoriesToRemove
    )
    $directoriesToRemove |% {
        $fulldirectoryPath = Join-Path $scriptDir $_
         if (Test-Path $fulldirectoryPath) 
         {
            Write-Host "Removing directory: $fulldirectoryPath" -ForegroundColor Green
            try 
            {
                Remove-Item $fulldirectoryPath -Recurse -Force -ErrorAction Stop
            } 
            catch 
            {
                Write-Host "Warning: failed to remove directory: $_" -ForegroundColor Yellow
            }
         }
    }
    
}
# Centralized configuration (edit here)
$PublishRoot = Join-Path $scriptDir 'publish'
$projectName = "Asionyx"
$solutionFileName = "$($projectName).sln"
$DeploymentProjectPath = Join-Path $scriptDir "$($projectName).Services.Deployment"
$SystemdProjectPath = Join-Path $scriptDir "$($projectName).Services.Deployment.SystemD"
$HelloWorldProjectPath = Join-Path $scriptDir "$($projectName).Services.HelloWorld"
$Dockerfile = "$($projectName).Services.Deployment.Docker/Dockerfile"
$DockerImage = 'asionyx/deployment:local'
$ContainerName = 'asionyx_local'
$HostPort = 5000
$MaxWaitSeconds = 60
$ShouldCleanupDockerImage = $false


# Build context object passed to every function
$buildContext = [PSCustomObject]@{
    ScriptDir = $scriptDir
    PublishRoot = $PublishRoot
    ProjectName = $projectName
    DeploymentProjectPath = $DeploymentProjectPath
    SystemdProjectPath = $SystemdProjectPath
    HelloWorldProjectPath = $HelloWorldProjectPath
    Dockerfile = $Dockerfile
    DockerImage = $DockerImage
    ContainerName = $ContainerName
    HostPort = $HostPort
    MaxWaitSeconds = $MaxWaitSeconds
    ShouldCleanupDockerImage = $ShouldCleanupDockerImage
    SolutionFileName = $solutionFileName
}

Remove-Directories -directoriesToRemove @('publish', 'artifacts', "TestResults")
Install-ReportGeneratorTool
Restore-Solution -buildContext $buildContext
Publish-Projects -buildContext $buildContext
Invoke-DockerBuild -buildContext $buildContext

# Run integration tests but always remove the built image afterwards. Container
# lifecycle remains managed by the tests themselves.
try {
    Test-Integration -buildContext $buildContext
    New-CoverageReport -buildContext $buildContext -covFiles $script:covFiles
} finally {
    Remove-DockerImage -buildContext $buildContext
    Save-LogsAndCleanup -buildContext $buildContext
}